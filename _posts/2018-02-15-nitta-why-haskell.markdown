---
layout: post
title:  "NITTA: Почему Haskell?"
description: Почему в проекте NITTA было принято решение использовать язык программирования Haskell?
date:   2018-02-15 12:00:00 +0300
---

Сперва хочется отметить, что язык Haskell был выбран как необходимое зло для данного проекта. Экзотичность и суровая кривая обучения данного языка является серьёзной проблемой. Были сделаны попытки найти альтернативные варианты (Python, Clojure, Rust), но, как не странно, именно Haskell оказался наиболее практичным и удобным решением. С другими языками либо проваливалась производительность, либо усложнялось тестирование, либо возлагались серьёзные ограничения на стиль программирования. Не просто так Haskell популярен в среде компиляторо-строения.

Следующие особенности проекта и языка стали определяющими:

1. Метод синтеза. В его основе лежит имитационная модель целевого вычислителя, используя которую система синтеза перебирает возможные варианты организации вычислительного процесса. В случае если выясняется, что выбранный вариант неудовлетворителен -- необходимо осуществить откат части принятых решений. Haskell - функциональный язык программирования работающий с неизменяемыми данными (вместо того что бы обновить значение в словаре, мы создаём новый словарь), и вся его инфраструктура рассчитана на это. Это позволяет нам:
    - Получить функцию «отката изменений» бесплатно, безопасно и при этом не нагружая программиста или инструментальную машину.
    - Обеспечить параллельную работу без гонок и задаром.
2. Разрабатываемый САПР является сложным программным продуктом включающим в себя большое количество тесно связанных компонент. При этом состав компонент и их функциональность будут часто меняться, особенно на первых этапах. Это ставит проблему обеспечения согласованности компонент системы, решением которой обычно является строгая статическая типизация. Про Haskell часто говорят, что если программа «собралась», то она будет работать. Конечно это не так, но если сравнить с привычными языками, то это скорее правда.
3. При решении комплексных вычислительных задач не требующих ввода/вывода, с большим количеством условий и инвариантов, серьёзную проблему представляет управление порядком вычислений. Когда какую метрику рассчитать. Что посчитать сейчас, а что по мере анализа вариантов. Будучи ленивым языком программирования, язык Haskell разбирается с этой проблемой сам, без участия программиста, что значительно упрощает процесс разработки (и несколько затрудняет процесс отладки).
4. Интересные и эффективные приемы разработки:
    - поддержка embedded domain specific language;
    - верификация на основе свойств ([QuickCheck](https://hackage.haskell.org/package/QuickCheck));
    - элементы зависимых типов.
5. https://www.haskell.org
